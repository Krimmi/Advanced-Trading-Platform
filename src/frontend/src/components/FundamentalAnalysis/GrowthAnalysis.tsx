import React, { useState, useEffect } from 'react';
import { 
  Box, 
  Typography, 
  Grid, 
  Paper, 
  Tabs, 
  Tab, 
  CircularProgress,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Chip,
  Tooltip,
  IconButton,
  Card,
  CardContent,
  Divider,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  FormControlLabel,
  Switch
} from '@mui/material';
import InfoIcon from '@mui/icons-material/Info';
import TrendingUpIcon from '@mui/icons-material/TrendingUp';
import TrendingDownIcon from '@mui/icons-material/TrendingDown';
import TrendingFlatIcon from '@mui/icons-material/TrendingFlat';
import {
  LineChart,
  Line,
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  ResponsiveContainer,
  Legend,
  Tooltip as RechartsTooltip,
  ComposedChart,
  Area,
  ReferenceLine
} from 'recharts';
import financialAnalysisService from '../../services/financialAnalysisService';

interface GrowthAnalysisProps {
  symbol: string;
}

interface TabPanelProps {
  children?: React.ReactNode;
  index: number;
  value: number;
}

function TabPanel(props: TabPanelProps) {
  const { children, value, index, ...other } = props;

  return (
    <div
      role="tabpanel"
      hidden={value !== index}
      id={`growth-tabpanel-${index}`}
      aria-labelledby={`growth-tab-${index}`}
      {...other}
    >
      {value === index && <Box sx={{ pt: 2 }}>{children}</Box>}
    </div>
  );
}

// Growth metrics descriptions
const growthMetricDescriptions: Record<string, string> = {
  revenue: "Total income from sales of goods or services before any costs or expenses are deducted.",
  grossProfit: "Revenue minus cost of goods sold (COGS). Shows how efficiently a company uses labor and supplies in production.",
  operatingIncome: "Profit from core business operations, excluding deductions of interest and taxes.",
  netIncome: "Company's total earnings or profit. Also known as the bottom line.",
  eps: "Net income divided by the number of outstanding shares. Shows the portion of a company's profit allocated to each share.",
  ebitda: "Earnings before interest, taxes, depreciation, and amortization. Measures operational profitability.",
  totalAssets: "Sum of all assets owned by a company, including current and non-current assets.",
  totalEquity: "Assets minus liabilities. Represents the shareholders' stake in the company.",
  freeCashFlow: "Cash generated by a company after accounting for capital expenditures. Shows ability to generate cash.",
  dividends: "Portion of earnings paid to shareholders, usually quarterly.",
  bookValue: "Net asset value of a company calculated as total assets minus intangible assets and liabilities.",
  marketCap: "Total market value of a company's outstanding shares. Calculated by multiplying share price by number of shares."
};

// Growth rate categories
const growthCategories = {
  financial: ['revenue', 'grossProfit', 'operatingIncome', 'netIncome', 'eps', 'ebitda'],
  balance: ['totalAssets', 'totalEquity', 'bookValue'],
  cash: ['freeCashFlow', 'dividends'],
  valuation: ['marketCap']
};

// Colors for charts
const COLORS = ['#0088FE', '#00C49F', '#FFBB28', '#FF8042', '#8884d8'];

const GrowthAnalysis: React.FC<GrowthAnalysisProps> = ({ symbol }) => {
  const [tabValue, setTabValue] = useState<number>(0);
  const [loading, setLoading] = useState<boolean>(true);
  const [growthData, setGrowthData] = useState<any>(null);
  const [timeframe, setTimeframe] = useState<string>('annual');
  const [selectedMetrics, setSelectedMetrics] = useState<string[]>(['revenue', 'grossProfit', 'operatingIncome', 'netIncome']);
  const [showCAGR, setShowCAGR] = useState<boolean>(false);
  const [industryComparison, setIndustryComparison] = useState<boolean>(true);
  
  useEffect(() => {
    fetchGrowthData();
  }, [symbol, timeframe]);

  const fetchGrowthData = async () => {
    setLoading(true);
    try {
      const data = await financialAnalysisService.getGrowthAnalysis(symbol, timeframe);
      setGrowthData(data);
      
      // Set default selected metrics based on tab
      if (tabValue === 0) {
        setSelectedMetrics(['revenue', 'grossProfit', 'operatingIncome', 'netIncome']);
      } else if (tabValue === 1) {
        setSelectedMetrics(['totalAssets', 'totalEquity', 'bookValue']);
      } else if (tabValue === 2) {
        setSelectedMetrics(['freeCashFlow', 'dividends']);
      } else if (tabValue === 3) {
        setSelectedMetrics(['marketCap']);
      }
    } catch (error) {
      console.error('Error fetching growth data:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleTabChange = (event: React.SyntheticEvent, newValue: number) => {
    setTabValue(newValue);
    
    // Update selected metrics based on tab
    if (newValue === 0) {
      setSelectedMetrics(['revenue', 'grossProfit', 'operatingIncome', 'netIncome']);
    } else if (newValue === 1) {
      setSelectedMetrics(['totalAssets', 'totalEquity', 'bookValue']);
    } else if (newValue === 2) {
      setSelectedMetrics(['freeCashFlow', 'dividends']);
    } else if (newValue === 3) {
      setSelectedMetrics(['marketCap']);
    }
  };

  // Format currency values
  const formatCurrency = (value: number): string => {
    if (value === undefined || value === null) return 'N/A';
    
    if (Math.abs(value) >= 1e12) {
      return `$${(value / 1e12).toFixed(2)}T`;
    } else if (Math.abs(value) >= 1e9) {
      return `$${(value / 1e9).toFixed(2)}B`;
    } else if (Math.abs(value) >= 1e6) {
      return `$${(value / 1e6).toFixed(2)}M`;
    } else {
      return `$${value.toLocaleString()}`;
    }
  };

  // Format percentage values
  const formatPercentage = (value: number): string => {
    if (value === undefined || value === null) return 'N/A';
    return `${value.toFixed(2)}%`;
  };

  // Format metric name for display
  const formatMetricName = (name: string): string => {
    return name
      .replace(/([A-Z])/g, ' $1') // Insert a space before all capital letters
      .replace(/^./, (str) => str.toUpperCase()); // Capitalize the first letter
  };

  // Get trend direction for a metric
  const getTrendDirection = (data: any[], metric: string): 'up' | 'down' | 'flat' => {
    if (!data || data.length < 2) return 'flat';
    
    const sortedData = [...data].sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
    const first = sortedData[0][metric];
    const last = sortedData[sortedData.length - 1][metric];
    
    if (first === undefined || last === undefined) return 'flat';
    
    // Calculate percentage change
    const change = ((last - first) / Math.abs(first)) * 100;
    
    if (change > 5) return 'up';
    if (change < -5) return 'down';
    return 'flat';
  };

  // Get color based on trend direction
  const getTrendColor = (trend: 'up' | 'down' | 'flat'): string => {
    if (trend === 'up') return '#4caf50'; // Green for up
    if (trend === 'down') return '#f44336'; // Red for down
    return '#757575'; // Gray for flat
  };

  // Get trend icon based on direction
  const getTrendIcon = (trend: 'up' | 'down' | 'flat', color: string) => {
    if (trend === 'up') return <TrendingUpIcon sx={{ color }} />;
    if (trend === 'down') return <TrendingDownIcon sx={{ color }} />;
    return <TrendingFlatIcon sx={{ color }} />;
  };

  // Calculate CAGR (Compound Annual Growth Rate)
  const calculateCAGR = (data: any[], metric: string): number | null => {
    if (!data || data.length < 2) return null;
    
    const sortedData = [...data].sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
    const firstValue = sortedData[0][metric];
    const lastValue = sortedData[sortedData.length - 1][metric];
    const years = sortedData.length - 1;
    
    if (firstValue <= 0 || lastValue <= 0 || years <= 0) return null;
    
    // CAGR = (End Value / Start Value)^(1 / Years) - 1
    return (Math.pow(lastValue / firstValue, 1 / years) - 1) * 100;
  };

  // Prepare data for growth charts
  const prepareGrowthChartData = (metrics: string[]): any[] => {
    if (!growthData || !growthData.historicalData || growthData.historicalData.length === 0) return [];
    
    const sortedData = [...growthData.historicalData].sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
    
    return sortedData.map(item => {
      const result: any = {
        date: timeframe === 'annual' ? item.year : `Q${item.quarter} ${item.year}`
      };
      
      metrics.forEach(metric => {
        result[metric] = item[metric];
        
        // Add industry average if available
        if (industryComparison && growthData.industryAverages && growthData.industryAverages[metric]) {
          const industryData = growthData.industryAverages[metric].find((avg: any) => 
            (timeframe === 'annual' && avg.year === item.year) || 
            (timeframe === 'quarterly' && avg.year === item.year && avg.quarter === item.quarter)
          );
          
          if (industryData) {
            result[`${metric}Industry`] = industryData.value;
          }
        }
      });
      
      return result;
    });
  };

  // Prepare data for growth rate charts
  const prepareGrowthRateChartData = (metrics: string[]): any[] => {
    if (!growthData || !growthData.growthRates || growthData.growthRates.length === 0) return [];
    
    const sortedData = [...growthData.growthRates].sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
    
    return sortedData.map(item => {
      const result: any = {
        date: timeframe === 'annual' ? item.year : `Q${item.quarter} ${item.year}`
      };
      
      metrics.forEach(metric => {
        result[metric] = item[`${metric}Growth`];
        
        // Add industry average if available
        if (industryComparison && growthData.industryAverages && growthData.industryAverages[`${metric}Growth`]) {
          const industryData = growthData.industryAverages[`${metric}Growth`].find((avg: any) => 
            (timeframe === 'annual' && avg.year === item.year) || 
            (timeframe === 'quarterly' && avg.year === item.year && avg.quarter === item.quarter)
          );
          
          if (industryData) {
            result[`${metric}Industry`] = industryData.value;
          }
        }
      });
      
      return result;
    });
  };

  // Get available metrics based on category
  const getAvailableMetrics = (category: string): { value: string, label: string }[] => {
    const metrics = growthCategories[category as keyof typeof growthCategories] || [];
    
    return metrics.map(metric => ({
      value: metric,
      label: formatMetricName(metric)
    }));
  };

  // Get category based on tab value
  const getCategoryFromTab = (tab: number): string => {
    switch (tab) {
      case 0: return 'financial';
      case 1: return 'balance';
      case 2: return 'cash';
      case 3: return 'valuation';
      default: return 'financial';
    }
  };

  // Render growth summary cards
  const renderGrowthSummaryCards = () => {
    if (!growthData || !growthData.summary) {
      return (
        <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>
          <Typography variant="body1">No growth summary data available</Typography>
        </Box>
      );
    }
    
    const category = getCategoryFromTab(tabValue);
    const metrics = growthCategories[category as keyof typeof growthCategories] || [];
    
    return (
      <Grid container spacing={2} sx={{ mb: 3 }}>
        {metrics.map(metric => {
          const summary = growthData.summary[metric];
          if (!summary) return null;
          
          const trend = summary.trend === 'increasing' ? 'up' : summary.trend === 'decreasing' ? 'down' : 'flat';
          const trendColor = getTrendColor(trend);
          
          return (
            <Grid item xs={12} sm={6} md={4} key={metric}>
              <Card variant="outlined">
                <CardContent>
                  <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 1 }}>
                    <Typography variant="subtitle1" component="div">
                      {formatMetricName(metric)}
                    </Typography>
                    <Tooltip title={growthMetricDescriptions[metric] || ''}>
                      <IconButton size="small">
                        <InfoIcon fontSize="small" />
                      </IconButton>
                    </Tooltip>
                  </Box>
                  
                  <Box sx={{ display: 'flex', alignItems: 'baseline', mb: 1 }}>
                    <Typography variant="h5" component="div" sx={{ mr: 1 }}>
                      {formatPercentage(summary.cagr)}
                    </Typography>
                    <Typography variant="body2" color="text.secondary">
                      CAGR
                    </Typography>
                    {getTrendIcon(trend, trendColor)}
                  </Box>
                  
                  <Divider sx={{ my: 1 }} />
                  
                  <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                    <Typography variant="body2" color="text.secondary">
                      1-Year Growth:
                    </Typography>
                    <Typography variant="body2" fontWeight="medium" color={summary.oneYearGrowth > 0 ? 'success.main' : 'error.main'}>
                      {formatPercentage(summary.oneYearGrowth)}
                    </Typography>
                  </Box>
                  
                  <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                    <Typography variant="body2" color="text.secondary">
                      3-Year Growth:
                    </Typography>
                    <Typography variant="body2" fontWeight="medium" color={summary.threeYearGrowth > 0 ? 'success.main' : 'error.main'}>
                      {formatPercentage(summary.threeYearGrowth)}
                    </Typography>
                  </Box>
                  
                  <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                    <Typography variant="body2" color="text.secondary">
                      5-Year Growth:
                    </Typography>
                    <Typography variant="body2" fontWeight="medium" color={summary.fiveYearGrowth > 0 ? 'success.main' : 'error.main'}>
                      {formatPercentage(summary.fiveYearGrowth)}
                    </Typography>
                  </Box>
                  
                  {industryComparison && summary.industryComparison && (
                    <>
                      <Divider sx={{ my: 1 }} />
                      <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                        <Typography variant="body2" color="text.secondary">
                          Industry CAGR:
                        </Typography>
                        <Typography variant="body2" fontWeight="medium">
                          {formatPercentage(summary.industryComparison.cagr)}
                        </Typography>
                      </Box>
                      <Box sx={{ display: 'flex', justifyContent: 'space-between' }}>
                        <Typography variant="body2" color="text.secondary">
                          Vs. Industry:
                        </Typography>
                        <Typography 
                          variant="body2" 
                          fontWeight="medium"
                          color={(summary.cagr - summary.industryComparison.cagr) > 0 ? 'success.main' : 'error.main'}
                        >
                          {formatPercentage(summary.cagr - summary.industryComparison.cagr)}
                        </Typography>
                      </Box>
                    </>
                  )}
                </CardContent>
              </Card>
            </Grid>
          );
        })}
      </Grid>
    );
  };

  // Render absolute values chart
  const renderAbsoluteValuesChart = () => {
    if (!growthData || !growthData.historicalData || growthData.historicalData.length === 0) {
      return (
        <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>
          <Typography variant="body1">No historical data available</Typography>
        </Box>
      );
    }
    
    const data = prepareGrowthChartData(selectedMetrics);
    
    return (
      <Paper sx={{ p: 2, height: '400px', mb: 3 }}>
        <Typography variant="h6" align="center" gutterBottom>
          Historical Values
        </Typography>
        <ResponsiveContainer width="100%" height="90%">
          <LineChart
            data={data}
            margin={{ top: 20, right: 30, left: 20, bottom: 10 }}
          >
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey="date" />
            <YAxis 
              tickFormatter={(value) => formatCurrency(value).replace('$', '')}
            />
            <RechartsTooltip 
              formatter={(value: any, name: string) => {
                // Check if this is an industry metric
                if (name.endsWith('Industry')) {
                  const baseName = name.replace('Industry', '');
                  return [formatCurrency(value), `${formatMetricName(baseName)} (Industry)`];
                }
                return [formatCurrency(value), formatMetricName(name)];
              }}
            />
            <Legend />
            {selectedMetrics.map((metric, index) => (
              <React.Fragment key={metric}>
                <Line
                  type="monotone"
                  dataKey={metric}
                  name={formatMetricName(metric)}
                  stroke={COLORS[index % COLORS.length]}
                  activeDot={{ r: 8 }}
                  strokeWidth={2}
                />
                {industryComparison && (
                  <Line
                    type="monotone"
                    dataKey={`${metric}Industry`}
                    name={`${formatMetricName(metric)} (Industry)`}
                    stroke={COLORS[index % COLORS.length]}
                    strokeDasharray="5 5"
                    strokeWidth={1}
                  />
                )}
              </React.Fragment>
            ))}
          </LineChart>
        </ResponsiveContainer>
      </Paper>
    );
  };

  // Render growth rates chart
  const renderGrowthRatesChart = () => {
    if (!growthData || !growthData.growthRates || growthData.growthRates.length === 0) {
      return (
        <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>
          <Typography variant="body1">No growth rate data available</Typography>
        </Box>
      );
    }
    
    const data = prepareGrowthRateChartData(selectedMetrics);
    
    return (
      <Paper sx={{ p: 2, height: '400px', mb: 3 }}>
        <Typography variant="h6" align="center" gutterBottom>
          Growth Rates {showCAGR ? '(CAGR)' : '(Year-over-Year)'}
        </Typography>
        <ResponsiveContainer width="100%" height="90%">
          <ComposedChart
            data={data}
            margin={{ top: 20, right: 30, left: 20, bottom: 10 }}
          >
            <CartesianGrid strokeDasharray="3 3" />
            <XAxis dataKey="date" />
            <YAxis 
              tickFormatter={(value) => `${value}%`}
            />
            <RechartsTooltip 
              formatter={(value: any, name: string) => {
                // Check if this is an industry metric
                if (name.endsWith('Industry')) {
                  const baseName = name.replace('Industry', '');
                  return [`${value.toFixed(2)}%`, `${formatMetricName(baseName)} (Industry)`];
                }
                return [`${value.toFixed(2)}%`, formatMetricName(name)];
              }}
            />
            <Legend />
            <ReferenceLine y={0} stroke="#000" />
            {selectedMetrics.map((metric, index) => (
              <React.Fragment key={metric}>
                <Bar
                  dataKey={metric}
                  name={formatMetricName(metric)}
                  fill={COLORS[index % COLORS.length]}
                  barSize={20}
                />
                {industryComparison && (
                  <Line
                    type="monotone"
                    dataKey={`${metric}Industry`}
                    name={`${formatMetricName(metric)} (Industry)`}
                    stroke={COLORS[index % COLORS.length]}
                    strokeDasharray="5 5"
                    strokeWidth={2}
                    dot={{ r: 4 }}
                  />
                )}
              </React.Fragment>
            ))}
          </ComposedChart>
        </ResponsiveContainer>
      </Paper>
    );
  };

  // Render growth rates table
  const renderGrowthRatesTable = () => {
    if (!growthData || !growthData.growthRates || growthData.growthRates.length === 0) {
      return (
        <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>
          <Typography variant="body1">No growth rate data available</Typography>
        </Box>
      );
    }
    
    const category = getCategoryFromTab(tabValue);
    const metrics = growthCategories[category as keyof typeof growthCategories] || [];
    const sortedData = [...growthData.growthRates].sort((a, b) => new Date(a.date).getTime() - new Date(b.date).getTime());
    
    return (
      <TableContainer component={Paper} variant="outlined">
        <Table size="small">
          <TableHead>
            <TableRow>
              <TableCell>Period</TableCell>
              {metrics.map((metric) => (
                <TableCell key={metric} align="right">
                  {formatMetricName(metric)}
                </TableCell>
              ))}
            </TableRow>
          </TableHead>
          <TableBody>
            {sortedData.map((period) => (
              <TableRow key={period.date}>
                <TableCell component="th" scope="row">
                  {timeframe === 'annual' ? period.year : `Q${period.quarter} ${period.year}`}
                </TableCell>
                {metrics.map((metric) => {
                  const growthValue = period[`${metric}Growth`];
                  
                  return (
                    <TableCell 
                      key={`${period.date}-${metric}`} 
                      align="right"
                      sx={{ 
                        color: growthValue > 0 ? 'success.main' : growthValue < 0 ? 'error.main' : 'text.primary'
                      }}
                    >
                      {typeof growthValue === 'number' 
                        ? formatPercentage(growthValue) 
                        : 'N/A'}
                    </TableCell>
                  );
                })}
              </TableRow>
            ))}
            
            {/* Add CAGR row if available */}
            {growthData.summary && (
              <TableRow sx={{ backgroundColor: 'action.hover' }}>
                <TableCell component="th" scope="row" sx={{ fontWeight: 'bold' }}>
                  CAGR
                </TableCell>
                {metrics.map((metric) => {
                  const summary = growthData.summary[metric];
                  const cagrValue = summary ? summary.cagr : null;
                  
                  return (
                    <TableCell 
                      key={`cagr-${metric}`} 
                      align="right"
                      sx={{ 
                        fontWeight: 'bold',
                        color: cagrValue > 0 ? 'success.main' : cagrValue < 0 ? 'error.main' : 'text.primary'
                      }}
                    >
                      {cagrValue !== null && cagrValue !== undefined
                        ? formatPercentage(cagrValue) 
                        : 'N/A'}
                    </TableCell>
                  );
                })}
              </TableRow>
            )}
            
            {/* Add industry comparison row if available */}
            {industryComparison && growthData.summary && (
              <TableRow sx={{ backgroundColor: 'action.selected' }}>
                <TableCell component="th" scope="row" sx={{ fontWeight: 'bold' }}>
                  Industry CAGR
                </TableCell>
                {metrics.map((metric) => {
                  const summary = growthData.summary[metric];
                  const industryCagr = summary && summary.industryComparison ? summary.industryComparison.cagr : null;
                  
                  return (
                    <TableCell 
                      key={`industry-${metric}`} 
                      align="right"
                      sx={{ fontWeight: 'bold' }}
                    >
                      {industryCagr !== null && industryCagr !== undefined
                        ? formatPercentage(industryCagr) 
                        : 'N/A'}
                    </TableCell>
                  );
                })}
              </TableRow>
            )}
          </TableBody>
        </Table>
      </TableContainer>
    );
  };

  return (
    <Box>
      <Box sx={{ mb: 3 }}>
        <Grid container spacing={2} alignItems="center">
          <Grid item>
            <Typography variant="h6">Growth Analysis</Typography>
          </Grid>
          <Grid item xs>
            <Tooltip title="Analysis of how key metrics have grown over time">
              <IconButton size="small">
                <InfoIcon />
              </IconButton>
            </Tooltip>
          </Grid>
          <Grid item>
            <FormControl size="small" sx={{ minWidth: 120 }}>
              <InputLabel id="timeframe-select-label">Timeframe</InputLabel>
              <Select
                labelId="timeframe-select-label"
                id="timeframe-select"
                value={timeframe}
                label="Timeframe"
                onChange={(e) => setTimeframe(e.target.value)}
              >
                <MenuItem value="annual">Annual</MenuItem>
                <MenuItem value="quarterly">Quarterly</MenuItem>
              </Select>
            </FormControl>
          </Grid>
          <Grid item>
            <FormControlLabel
              control={
                <Switch
                  checked={industryComparison}
                  onChange={(e) => setIndustryComparison(e.target.checked)}
                />
              }
              label="Industry Comparison"
            />
          </Grid>
        </Grid>
      </Box>

      <Box sx={{ borderBottom: 1, borderColor: 'divider' }}>
        <Tabs value={tabValue} onChange={handleTabChange} aria-label="growth analysis tabs">
          <Tab label="Financial Performance" />
          <Tab label="Balance Sheet" />
          <Tab label="Cash Flow" />
          <Tab label="Valuation" />
        </Tabs>
      </Box>

      {loading ? (
        <Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}>
          <CircularProgress />
        </Box>
      ) : (
        <>
          <Box sx={{ mt: 3 }}>
            <FormControl size="small" sx={{ minWidth: 200, mb: 2 }}>
              <InputLabel id="metrics-select-label">Select Metrics</InputLabel>
              <Select
                labelId="metrics-select-label"
                id="metrics-select"
                multiple
                value={selectedMetrics}
                onChange={(e) => setSelectedMetrics(e.target.value as string[])}
                renderValue={(selected) => (
                  <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 0.5 }}>
                    {(selected as string[]).map((value) => (
                      <Chip key={value} label={formatMetricName(value)} size="small" />
                    ))}
                  </Box>
                )}
                label="Select Metrics"
              >
                {getAvailableMetrics(getCategoryFromTab(tabValue)).map((metric) => (
                  <MenuItem key={metric.value} value={metric.value}>
                    {metric.label}
                  </MenuItem>
                ))}
              </Select>
            </FormControl>
            
            {renderGrowthSummaryCards()}
            {renderAbsoluteValuesChart()}
            {renderGrowthRatesChart()}
            {renderGrowthRatesTable()}
          </Box>
        </>
      )}
    </Box>
  );
};

export default GrowthAnalysis;