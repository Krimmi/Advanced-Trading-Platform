"""Risk metrics calculation module.This module provides classes and functions for calculating various risk metrics."""import numpy as npimport pandas as pdfrom typing import Dict, List, Any, Tuple, Optional, Unionimport scipy.stats as statsimport scipy.optimize as optimizeimport logging# Configure logginglogging.basicConfig(    level=logging.INFO,    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')logger = logging.getLogger("risk_metrics")class RiskMetrics:    """    Base class for calculating risk metrics for portfolios and assets.    """    def __init__(self, returns_data: pd.DataFrame, risk_free_rate: float = 0.0):        """        Initialize the risk metrics calculator.                Args:            returns_data: DataFrame of asset returns with DatetimeIndex            risk_free_rate: Annualized risk-free rate (default: 0.0)        """        self.returns = returns_data        self.risk_free_rate = risk_free_rate        self.daily_risk_free_rate = (1 + risk_free_rate) ** (1/252) - 1        self.assets = list(returns_data.columns)        self.num_assets = len(self.assets)        self.num_periods = len(returns_data)                # Calculate basic statistics        self.mean_returns = returns_data.mean()        self.cov_matrix = returns_data.cov()        self.std_dev = returns_data.std()                self.logger = logger        def calculate_portfolio_return(self, weights: np.ndarray) -> float:        """        Calculate expected portfolio return.                Args:            weights: Array of portfolio weights                    Returns:            Expected portfolio return        """        return np.sum(self.mean_returns * weights)        def calculate_portfolio_volatility(self, weights: np.ndarray) -> float:        """        Calculate portfolio volatility (standard deviation).                Args:            weights: Array of portfolio weights                    Returns:            Portfolio volatility        """        return np.sqrt(np.dot(weights.T, np.dot(self.cov_matrix, weights)))        def calculate_sharpe_ratio(self, weights: np.ndarray, annualized: bool = True) -> float:        """        Calculate Sharpe ratio.                Args:            weights: Array of portfolio weights            annualized: Whether to annualize the Sharpe ratio                    Returns:            Sharpe ratio        """        portfolio_return = self.calculate_portfolio_return(weights)        portfolio_volatility = self.calculate_portfolio_volatility(weights)                if annualized:            # Annualize returns and volatility            ann_return = (1 + portfolio_return) ** 252 - 1            ann_volatility = portfolio_volatility * np.sqrt(252)            return (ann_return - self.risk_free_rate) / ann_volatility if ann_volatility != 0 else 0        else:            return (portfolio_return - self.daily_risk_free_rate) / portfolio_volatility if portfolio_volatility != 0 else 0        def calculate_sortino_ratio(self, weights: np.ndarray, annualized: bool = True, target_return: float = 0.0) -> float:        """        Calculate Sortino ratio.                Args:            weights: Array of portfolio weights            annualized: Whether to annualize the Sortino ratio            target_return: Minimum acceptable return                    Returns:            Sortino ratio        """        portfolio_return = self.calculate_portfolio_return(weights)                # Calculate portfolio returns        portfolio_returns = np.sum(self.returns * weights, axis=1)                # Calculate downside deviation        downside_returns = portfolio_returns[portfolio_returns < target_return]        downside_deviation = np.sqrt(np.mean(downside_returns ** 2)) if len(downside_returns) > 0 else 0                if annualized:            # Annualize returns and downside deviation            ann_return = (1 + portfolio_return) ** 252 - 1            ann_downside_dev = downside_deviation * np.sqrt(252)            return (ann_return - self.risk_free_rate) / ann_downside_dev if ann_downside_dev != 0 else 0        else:            return (portfolio_return - self.daily_risk_free_rate) / downside_deviation if downside_deviation != 0 else 0        def calculate_value_at_risk(self, weights: np.ndarray, confidence_level: float = 0.95, time_horizon: int = 1) -> float:        """        Calculate Value at Risk (VaR) using parametric method.                Args:            weights: Array of portfolio weights            confidence_level: Confidence level (default: 0.95)            time_horizon: Time horizon in days (default: 1)                    Returns:            Value at Risk        """        portfolio_return = self.calculate_portfolio_return(weights)        portfolio_volatility = self.calculate_portfolio_volatility(weights)                # Calculate VaR        z_score = stats.norm.ppf(1 - confidence_level)        var = -(portfolio_return * time_horizon + z_score * portfolio_volatility * np.sqrt(time_horizon))                return var        def calculate_conditional_value_at_risk(self, weights: np.ndarray, confidence_level: float = 0.95, time_horizon: int = 1) -> float:        """        Calculate Conditional Value at Risk (CVaR) using parametric method.                Args:            weights: Array of portfolio weights            confidence_level: Confidence level (default: 0.95)            time_horizon: Time horizon in days (default: 1)                    Returns:            Conditional Value at Risk        """        portfolio_return = self.calculate_portfolio_return(weights)        portfolio_volatility = self.calculate_portfolio_volatility(weights)                # Calculate CVaR        z_score = stats.norm.ppf(1 - confidence_level)        var = -(portfolio_return * time_horizon + z_score * portfolio_volatility * np.sqrt(time_horizon))                # Expected shortfall (CVaR) for normal distribution        cvar = var + (stats.norm.pdf(z_score) / (1 - confidence_level)) * portfolio_volatility * np.sqrt(time_horizon)                return cvar        def calculate_historical_var(self, weights: np.ndarray, confidence_level: float = 0.95) -> float:        """        Calculate Value at Risk (VaR) using historical method.                Args:            weights: Array of portfolio weights            confidence_level: Confidence level (default: 0.95)                    Returns:            Historical Value at Risk        """        # Calculate portfolio returns        portfolio_returns = np.sum(self.returns * weights, axis=1)                # Calculate VaR        var = -np.percentile(portfolio_returns, 100 * (1 - confidence_level))                return var        def calculate_historical_cvar(self, weights: np.ndarray, confidence_level: float = 0.95) -> float:        """        Calculate Conditional Value at Risk (CVaR) using historical method.                Args:            weights: Array of portfolio weights            confidence_level: Confidence level (default: 0.95)                    Returns:            Historical Conditional Value at Risk        """        # Calculate portfolio returns        portfolio_returns = np.sum(self.returns * weights, axis=1)                # Calculate VaR        var = -np.percentile(portfolio_returns, 100 * (1 - confidence_level))                # Calculate CVaR        cvar = -portfolio_returns[portfolio_returns <= -var].mean()                return cvar        def calculate_maximum_drawdown(self, weights: np.ndarray) -> float:        """        Calculate maximum drawdown.                Args:            weights: Array of portfolio weights                    Returns:            Maximum drawdown        """        # Calculate portfolio returns        portfolio_returns = np.sum(self.returns * weights, axis=1)                # Calculate cumulative returns        cumulative_returns = (1 + portfolio_returns).cumprod()                # Calculate running maximum        running_max = np.maximum.accumulate(cumulative_returns)                # Calculate drawdown        drawdown = (cumulative_returns - running_max) / running_max                # Calculate maximum drawdown        max_drawdown = drawdown.min()                return max_drawdown        def calculate_beta(self, weights: np.ndarray, market_returns: pd.Series) -> float:        """        Calculate portfolio beta relative to market.                Args:            weights: Array of portfolio weights            market_returns: Series of market returns                    Returns:            Portfolio beta        """        # Calculate portfolio returns        portfolio_returns = np.sum(self.returns * weights, axis=1)                # Calculate covariance between portfolio and market        cov_portfolio_market = np.cov(portfolio_returns, market_returns)[0, 1]                # Calculate market variance        market_variance = np.var(market_returns)                # Calculate beta        beta = cov_portfolio_market / market_variance if market_variance != 0 else 0                return beta        def calculate_tracking_error(self, weights: np.ndarray, benchmark_returns: pd.Series) -> float:        """        Calculate tracking error relative to benchmark.                Args:            weights: Array of portfolio weights            benchmark_returns: Series of benchmark returns                    Returns:            Tracking error        """        # Calculate portfolio returns        portfolio_returns = np.sum(self.returns * weights, axis=1)                # Calculate tracking error        tracking_diff = portfolio_returns - benchmark_returns        tracking_error = np.std(tracking_diff)                return tracking_error        def calculate_information_ratio(self, weights: np.ndarray, benchmark_returns: pd.Series) -> float:        """        Calculate information ratio.                Args:            weights: Array of portfolio weights            benchmark_returns: Series of benchmark returns                    Returns:            Information ratio        """        # Calculate portfolio returns        portfolio_returns = np.sum(self.returns * weights, axis=1)                # Calculate active return        active_return = np.mean(portfolio_returns - benchmark_returns)                # Calculate tracking error        tracking_error = self.calculate_tracking_error(weights, benchmark_returns)                # Calculate information ratio        information_ratio = active_return / tracking_error if tracking_error != 0 else 0                return information_ratio        def calculate_risk_contribution(self, weights: np.ndarray) -> pd.Series:        """        Calculate risk contribution of each asset to portfolio risk.                Args:            weights: Array of portfolio weights                    Returns:            Series of risk contributions        """        portfolio_volatility = self.calculate_portfolio_volatility(weights)                # Calculate marginal risk contribution        marginal_risk = np.dot(self.cov_matrix, weights)                # Calculate risk contribution        risk_contribution = weights * marginal_risk / portfolio_volatility if portfolio_volatility != 0 else weights * 0                return pd.Series(risk_contribution, index=self.assets)        def calculate_risk_metrics_summary(self, weights: np.ndarray, market_returns: Optional[pd.Series] = None, benchmark_returns: Optional[pd.Series] = None) -> Dict[str, float]:        """        Calculate a summary of risk metrics for a portfolio.                Args:            weights: Array of portfolio weights            market_returns: Series of market returns (optional)            benchmark_returns: Series of benchmark returns (optional)                    Returns:            Dictionary of risk metrics        """        metrics = {}                # Basic metrics        metrics["expected_return"] = self.calculate_portfolio_return(weights)        metrics["volatility"] = self.calculate_portfolio_volatility(weights)        metrics["sharpe_ratio"] = self.calculate_sharpe_ratio(weights)        metrics["sortino_ratio"] = self.calculate_sortino_ratio(weights)                # VaR and CVaR        metrics["var_95"] = self.calculate_value_at_risk(weights, confidence_level=0.95)        metrics["cvar_95"] = self.calculate_conditional_value_at_risk(weights, confidence_level=0.95)        metrics["historical_var_95"] = self.calculate_historical_var(weights, confidence_level=0.95)        metrics["historical_cvar_95"] = self.calculate_historical_cvar(weights, confidence_level=0.95)                # Drawdown        metrics["max_drawdown"] = self.calculate_maximum_drawdown(weights)                # Market-related metrics        if market_returns is not None:            metrics["beta"] = self.calculate_beta(weights, market_returns)                # Benchmark-related metrics        if benchmark_returns is not None:            metrics["tracking_error"] = self.calculate_tracking_error(weights, benchmark_returns)            metrics["information_ratio"] = self.calculate_information_ratio(weights, benchmark_returns)                # Annualized metrics        metrics["annualized_return"] = (1 + metrics["expected_return"]) ** 252 - 1        metrics["annualized_volatility"] = metrics["volatility"] * np.sqrt(252)                return metrics        def run_monte_carlo_simulation(self, weights: np.ndarray, num_simulations: int = 1000, time_horizon: int = 252) -> pd.DataFrame:        """        Run Monte Carlo simulation for portfolio returns.                Args:            weights: Array of portfolio weights            num_simulations: Number of simulations to run            time_horizon: Time horizon in days                    Returns:            DataFrame of simulated portfolio values        """        # Calculate portfolio mean and volatility        portfolio_return = self.calculate_portfolio_return(weights)        portfolio_volatility = self.calculate_portfolio_volatility(weights)                # Initialize simulation results        simulation_results = np.zeros((time_horizon, num_simulations))                # Run simulations        for i in range(num_simulations):            # Generate random returns            random_returns = np.random.normal(portfolio_return, portfolio_volatility, time_horizon)                        # Calculate cumulative returns            cumulative_returns = (1 + random_returns).cumprod()                        # Store results            simulation_results[:, i] = cumulative_returns                # Convert to DataFrame        simulation_df = pd.DataFrame(simulation_results)                return simulation_df